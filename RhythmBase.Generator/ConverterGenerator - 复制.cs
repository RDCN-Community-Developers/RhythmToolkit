using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Text;

// 这坨写得太史了

namespace RhythmBase.Generator;

[Generator(LanguageNames.CSharp)]
public class ConverterGenerator : IIncrementalGenerator
{
	// Attribute 名称常量
	private const string JsonEnumAttrName = "RhythmBase.Global.Converters.RDJsonEnumSerializableAttribute";
	private const string JsonObjectNotSerializableAttrName = "RhythmBase.Global.Converters.RDJsonObjectNotSerializableAttribute";
	private const string JsonPropertyAttrName = "RhythmBase.Global.Converters.RDJsonPropertyAttribute";
	private const string JsonIgnoreAttrName = "RhythmBase.Global.Converters.RDJsonIgnoreAttribute";
	private const string JsonNotIgnoreAttrName = "RhythmBase.Global.Converters.RDJsonNotIgnoreAttribute";
	private const string JsonDefaultSerializerAttrName = "RhythmBase.Global.Converters.RDJsonDefaultSerializerAttribute";
	private const string JsonConditionAttrName = "RhythmBase.Global.Converters.RDJsonConditionAttribute";
	private const string JsonTimeAttrName = "RhythmBase.Global.Converters.RDJsonTimeAttribute";
	private const string JsonConverterAttrName = "RhythmBase.Global.Converters.RDJsonConverterAttribute";

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		GenerateAttribute(context);
		GenerateEnumConverter(context);
		GenerateEventConverterForRDLevel(context);
		GenerateEventConverterForADLevel(context);
		GenerateFilterConverter(context);

		// 预留：类处理
		// var classes = context.SyntaxProvider.CreateSyntaxProvider(
		// 	predicate: (s, _) => s is ClassDeclarationSyntax,
		// 	transform: (ctx, _) => { ... })
		// 	.Where(x => x.Item2)
		// 	.Select((x, _) => x.symbol)
		// 	.Collect();
	}
	#region Attribute 生成

	private static void GenerateAttribute(IncrementalGeneratorInitializationContext context)
	{
		context.RegisterPostInitializationOutput(ctx =>
		{
			ctx.AddSource("JsonSerializableAttribute.g.cs",
				"""
				using System;
				#pragma warning disable CS9113
				namespace RhythmBase.Global.Converters
				{
					internal sealed class RDJsonEnumSerializableAttribute : Attribute { }
					internal sealed class RDJsonObjectNotSerializableAttribute : Attribute { }
					internal sealed class RDJsonIgnoreAttribute : Attribute { }
					internal sealed class RDJsonNotIgnoreAttribute : Attribute { }
					internal sealed class RDJsonConditionAttribute(string condition) : Attribute { }
					internal sealed class RDJsonPropertyAttribute(string name) : Attribute { }
					internal sealed class RDJsonDefaultSerializerAttribute : Attribute { }
					internal sealed class RDJsonTimeAttribute(string type) : Attribute { }
					internal sealed class RDJsonConverterAttribute(Type converterType) : Attribute { }
				}
				"""
			);
		});
	}

	#endregion

	#region Enum Converter 生成

	private static void GenerateEnumConverter(IncrementalGeneratorInitializationContext context)
	{
		var enums = context.SyntaxProvider.CreateSyntaxProvider(
			predicate: (s, _) => s is EnumDeclarationSyntax,
			transform: (ctx, _) =>
			{
				var decl = (EnumDeclarationSyntax)ctx.Node;
				var symbol = ctx.SemanticModel.GetDeclaredSymbol(decl);
				return (symbol, symbol?.GetAttributes()
					.Any(a => a.AttributeClass?.ToDisplayString() == JsonEnumAttrName) == true);
			})
			.Where(x => x.Item2)
			.Select((x, _) => x.symbol)
			.Collect();

		context.RegisterSourceOutput(enums, (spc, enumSymbols) =>
		{
			var sb = new StringBuilder();
			sb.AppendLine("// <auto-generated/>");
			sb.AppendLine("#nullable enable");
			sb.AppendLine("using System;");
			sb.AppendLine("using System.Runtime.CompilerServices;");
			sb.AppendLine();
			sb.AppendLine("namespace RhythmBase.Global.Extensions");
			sb.AppendLine("{");
			sb.AppendLine("	/// <summary>");
			sb.AppendLine($"	/// Provides extension methods for converting enums to and from string representations.");
			sb.AppendLine("	/// </summary>");
			sb.AppendLine("	public static class EnumConverter");
			sb.AppendLine("	{");

			foreach (INamedTypeSymbol e in enumSymbols.Cast<INamedTypeSymbol>())
			{
				var fullName = e.ToDisplayString();
				sb.AppendLine($"/* {fullName} */");

				// TryParse(string)
				sb.AppendLine("		/// <summary>");
				sb.AppendLine($"		/// Attempts to parse the specified string value to a <see cref=\"{fullName}\"/> enum value.");
				sb.AppendLine("		/// </summary>");
				sb.AppendLine("		/// <param name=\"value\">The string representation of the enum value.</param>");
				sb.AppendLine($"		/// <param name=\"result\">When this method returns, contains the parsed <see cref=\"{fullName}\"/> value if parsing succeeded; otherwise, the default value.</param>");
				sb.AppendLine("		/// <returns><c>true</c> if parsing succeeded; otherwise, <c>false</c>.</returns>");
				sb.AppendLine("		[MethodImpl(MethodImplOptions.AggressiveInlining)]");
				sb.AppendLine($"		public static bool TryParse(string? value, out {fullName} result)");
				sb.AppendLine("		{");
				sb.AppendLine("			switch(value) {");
				foreach (var field in e.GetMembers().OfType<IFieldSymbol>())
				{
					if (field.HasConstantValue)
					{
						sb.AppendLine($"				case \"{field.Name}\":");
						sb.AppendLine($"					result = {fullName}.{field.Name};");
						sb.AppendLine("					return true;");
					}
				}
				sb.AppendLine("				default:");
				sb.AppendLine("					result = default;");
				sb.AppendLine("					return false;");
				sb.AppendLine("			}");
				sb.AppendLine("		}");
				sb.AppendLine();

				// TryParse(ReadOnlySpan<byte>)
				sb.AppendLine("		/// <summary>");
				sb.AppendLine($"		/// Attempts to parse the specified UTF-8 byte span to a <see cref=\"{fullName}\"/> enum value.");
				sb.AppendLine("		/// </summary>");
				sb.AppendLine("		/// <param name=\"value\">The UTF-8 byte span representing the enum value.</param>");
				sb.AppendLine($"		/// <param name=\"result\">When this method returns, contains the parsed <see cref=\"{fullName}\"/> value if parsing succeeded; otherwise, the default value.</param>");
				sb.AppendLine("		/// <returns><c>true</c> if parsing succeeded; otherwise, <c>false</c>.</returns>");
				sb.AppendLine("		[MethodImpl(MethodImplOptions.AggressiveInlining)]");
				sb.AppendLine($"		public static bool TryParse(ReadOnlySpan<byte> value, out {fullName} result)");
				sb.AppendLine("		{");
				bool isFirst = true;
				foreach (var field in e.GetMembers().OfType<IFieldSymbol>())
				{
					if (field.HasConstantValue && !(fullName.EndsWith("EventType") && (field.Name.StartsWith("Forward") || field.Name.EndsWith("Event"))))
					{
						sb.AppendLine(isFirst
							? $"			if (value.SequenceEqual(\"{field.Name}\"u8))"
							: $"			else if (value.SequenceEqual(\"{field.Name}\"u8))");
						sb.AppendLine("			{");
						sb.AppendLine($"				result = {fullName}.{field.Name};");
						sb.AppendLine("				return true;");
						sb.AppendLine("			}");
						isFirst = false;
					}
				}
				sb.AppendLine("			else");
				sb.AppendLine("			{");
				sb.AppendLine("				result = default;");
				sb.AppendLine("				return false;");
				sb.AppendLine("			}");
				sb.AppendLine("		}");
				sb.AppendLine();

				// ToEnumString
				sb.AppendLine("		/// <summary>");
				sb.AppendLine($"		/// Converts the <see cref=\"{fullName}\"/> enum value to its string representation.");
				sb.AppendLine("		/// </summary>");
				sb.AppendLine("		/// <param name=\"value\">The enum value to convert.</param>");
				sb.AppendLine("		/// <returns>The string representation of the enum value.</returns>");
				sb.AppendLine("		[MethodImpl(MethodImplOptions.AggressiveInlining)]");
				sb.AppendLine($"		public static string ToEnumString(this {fullName} value) => value switch");
				sb.AppendLine("		{");
				foreach (var field in e.GetMembers().OfType<IFieldSymbol>())
				{
					if (field.HasConstantValue)
						sb.AppendLine($"			{fullName}.{field.Name} => \"{field.Name}\",");
				}
				sb.AppendLine("			_ => value.ToString(),");
				sb.AppendLine("		};");
			}
			sb.AppendLine("	}");
			sb.AppendLine("}");

			spc.AddSource("EnumConverters.g.cs", sb.ToString());
		});
	}

	#endregion

	#region Event Converter 生成

	private static void GenerateEventConverterForRDLevel(IncrementalGeneratorInitializationContext context)
	{
		HashSet<string> names = [];
		var eventClasses = context.SyntaxProvider.CreateSyntaxProvider(
			predicate: (s, _) => s is ClassDeclarationSyntax,
			transform: (ctx, _) =>
			{
				var classDeclaration = (ClassDeclarationSyntax)ctx.Node;
				var symbol = ctx.SemanticModel.GetDeclaredSymbol(classDeclaration);
				if (symbol is INamedTypeSymbol namedTypeSymbol
				&& (namedTypeSymbol.AllInterfaces.Any(i => i.ToDisplayString().Contains("IBaseEvent")))//namedTypeSymbol.AllInterfaces.Any(i => i.Name.Contains("IBaseEvent"))
				&& (namedTypeSymbol.ContainingNamespace?.ToDisplayString().Contains("RhythmBase.RhythmDoctor.Events") ?? false)
				&& !namedTypeSymbol.IsAbstract
				)
				{
					INamedTypeSymbol? baseType = namedTypeSymbol.BaseType;
					if (names.Add(symbol.Name))
						return (symbol, baseType);
				}
#pragma warning disable CS8619 // 值中的引用类型的为 Null 性与目标类型不匹配。
				return (null, null);
#pragma warning restore CS8619 // 值中的引用类型的为 Null 性与目标类型不匹配。
			})
			.Where(i => i.symbol is not null)
			.Collect();

		context.RegisterSourceOutput(eventClasses, (ctx, symbols) =>
		{
			var sb = new StringBuilder();
			sb.AppendLine("// <auto-generated/>");
			sb.AppendLine("#nullable enable");
			sb.AppendLine();
			sb.AppendLine("using System;");
			sb.AppendLine("using RhythmBase.Global.Extensions;");
			sb.AppendLine("using RhythmBase.Global.Components;");
			sb.AppendLine("using RhythmBase.Global.Components.Easing;");
			sb.AppendLine("using RhythmBase.Global.Components.RichText;");
			sb.AppendLine("using RhythmBase.RhythmDoctor.Events;");
			sb.AppendLine("using RhythmBase.RhythmDoctor.Components;");
			sb.AppendLine("using System.Text.Json;");
			sb.AppendLine("using static RhythmBase.Global.Extensions.EnumConverter;");
			sb.AppendLine();
			sb.AppendLine("namespace RhythmBase.RhythmDoctor.Converters;");
			sb.AppendLine();

			foreach (var (symbol, baseType) in symbols
				.Where(i => !i.symbol.GetAttributes().Any(a => a.AttributeClass?.ToDisplayString() == JsonObjectNotSerializableAttrName))
				.OrderBy(i => i.symbol.Name))
			{
				if (symbol is null)
					continue;
				INamedTypeSymbol e = symbol;
				var properties = e.GetMembers()
					.OfType<IPropertySymbol>()
					.Where(p =>
						p.DeclaredAccessibility.HasFlag(Accessibility.Public) && p.SetMethod != null ||
						p.GetAttributes().Any(i => i.AttributeClass?.ToDisplayString() == JsonNotIgnoreAttrName))
					.ToList();

				sb.AppendLine($"internal class EventInstanceConverter{e.Name} : EventInstanceConverter{baseType?.Name}<{e.ToDisplayString()}>");
				sb.AppendLine("{");
				// Read
				sb.AppendLine($"	protected override bool Read(ref Utf8JsonReader reader, ReadOnlySpan<byte> propertyName, ref {e.ToDisplayString()} value, JsonSerializerOptions options)");
				sb.AppendLine("	{");
				if (properties.Count > 0)
				{
					sb.AppendLine("		if(base.Read(ref reader, propertyName, ref value, options))");
					sb.AppendLine("			return true;");
					AppendEventReadBody(sb, properties, e);
				}
				else
				{
					sb.AppendLine("		return base.Read(ref reader, propertyName, ref value, options);");
				}
				sb.AppendLine("	}");

				// Write
				sb.AppendLine($"	protected override void Write(Utf8JsonWriter writer, ref {e.Name} value, JsonSerializerOptions options)");
				sb.AppendLine("	{");
				sb.AppendLine("		base.Write(writer, ref value, options);");
				AppendEventWriteBody(sb, properties, e);
				sb.AppendLine("	}");
				sb.AppendLine("}");
			}
			ctx.AddSource("EventInstanceConvertersRDLevel.g.cs", sb.ToString());

			// EventTypeUtils
			sb.Clear();
			sb.AppendLine("// <auto-generated/>");
			sb.AppendLine("#nullable enable");
			sb.AppendLine();
			sb.AppendLine("using System;");
			sb.AppendLine();
			sb.AppendLine("namespace RhythmBase.RhythmDoctor.Utils;");
			sb.AppendLine();
			sb.AppendLine("partial class EventTypeUtils");
			sb.AppendLine("{");
			sb.AppendLine("	internal static System.Collections.ObjectModel.ReadOnlyDictionary<RhythmBase.RhythmDoctor.Events.EventType, RhythmBase.RhythmDoctor.Converters.EventInstanceConverterBase> converters = new(new Dictionary<RhythmBase.RhythmDoctor.Events.EventType, RhythmBase.RhythmDoctor.Converters.EventInstanceConverterBase>()");
			sb.AppendLine("	{");
			foreach (var (symbol, _) in symbols
				.Where(i => !(i.symbol.Name.StartsWith("Forward") && i.symbol.Name.EndsWith("Event")))
				.OrderBy(i => i.symbol.Name))
			{
				sb.AppendLine($"			[RhythmBase.RhythmDoctor.Events.EventType.{symbol.Name}] = new RhythmBase.RhythmDoctor.Converters.EventInstanceConverter{symbol.Name}(),");
			}
			sb.AppendLine("	});");
			sb.AppendLine("}");
			ctx.AddSource("EventTypeUtilsRDLevel.g.cs", sb.ToString());
		});
	}

	private static void GenerateEventConverterForADLevel(IncrementalGeneratorInitializationContext context)
	{
		HashSet<string> names = [];
		var eventClasses = context.SyntaxProvider.CreateSyntaxProvider(
			predicate: (s, _) => s is ClassDeclarationSyntax,
			transform: (ctx, _) =>
			{
				var classDeclaration = (ClassDeclarationSyntax)ctx.Node;
				var symbol = ctx.SemanticModel.GetDeclaredSymbol(classDeclaration);
				if (symbol is INamedTypeSymbol namedTypeSymbol &&
					namedTypeSymbol.AllInterfaces.Any(i => i.Name == "IBaseEvent") &&
				(namedTypeSymbol.ContainingNamespace?.ToDisplayString() == "RhythmBase.Adofai.Events") &&
					!namedTypeSymbol.IsAbstract)
				{
					INamedTypeSymbol? baseType = namedTypeSymbol.BaseType;
					if (names.Add(symbol.Name))
						return (symbol, baseType);
				}
#pragma warning disable CS8619 // 值中的引用类型的为 Null 性与目标类型不匹配。
				return (null, null);
#pragma warning restore CS8619 // 值中的引用类型的为 Null 性与目标类型不匹配。
			})
			.Where(i => i.symbol is not null)
			.Collect();

		context.RegisterSourceOutput(eventClasses, (ctx, symbols) =>
		{
			var sb = new StringBuilder();
			sb.AppendLine("// <auto-generated/>");
			sb.AppendLine("#nullable enable");
			sb.AppendLine();
			sb.AppendLine("using System;");
			sb.AppendLine("using RhythmBase.Global.Extensions;");
			sb.AppendLine("using RhythmBase.Global.Components;");
			sb.AppendLine("using RhythmBase.Global.Components.Easing;");
			sb.AppendLine("using RhythmBase.Global.Components.RichText;");
			sb.AppendLine("using RhythmBase.Adofai.Events;");
			sb.AppendLine("using RhythmBase.Adofai.Components;");
			sb.AppendLine("using System.Text.Json;");
			sb.AppendLine("using static RhythmBase.Global.Extensions.EnumConverter;");
			sb.AppendLine();
			sb.AppendLine("namespace RhythmBase.Adofai.Converters;");
			sb.AppendLine();

			foreach (var (symbol, baseType) in symbols
				.Where(i => !i.symbol.GetAttributes().Any(a => a.AttributeClass?.ToDisplayString() == JsonObjectNotSerializableAttrName))
				.OrderBy(i => i.symbol.Name))
			{
				if (symbol is null)
					continue;
				INamedTypeSymbol e = symbol;
				var properties = e.GetMembers()
					.OfType<IPropertySymbol>()
					.Where(p =>
						p.DeclaredAccessibility.HasFlag(Accessibility.Public) && p.SetMethod != null ||
						p.GetAttributes().Any(i => i.AttributeClass?.ToDisplayString() == JsonNotIgnoreAttrName))
					.ToList();

				sb.AppendLine($"internal class EventInstanceConverter{e.Name} : EventInstanceConverter{baseType?.Name}<{e.ToDisplayString()}>");
				sb.AppendLine("{");
				// Read
				sb.AppendLine($"	protected override bool Read(ref Utf8JsonReader reader, ReadOnlySpan<byte> propertyName, ref {e.ToDisplayString()} value, JsonSerializerOptions options)");
				sb.AppendLine("	{");
				if (properties.Count > 0)
				{
					sb.AppendLine("		if(base.Read(ref reader, propertyName, ref value, options))");
					sb.AppendLine("			return true;");
					AppendEventReadBody(sb, properties, e);
				}
				else
				{
					sb.AppendLine("		return base.Read(ref reader, propertyName, ref value, options);");
				}
				sb.AppendLine("	}");

				// Write
				sb.AppendLine($"	protected override void Write(Utf8JsonWriter writer, ref {e.Name} value, JsonSerializerOptions options)");
				sb.AppendLine("	{");
				sb.AppendLine("		base.Write(writer, ref value, options);");
				AppendEventWriteBody(sb, properties, e);
				sb.AppendLine("	}");
				sb.AppendLine("}");
			}
			ctx.AddSource("EventInstanceConvertersADLevel.g.cs", sb.ToString());

			// EventTypeUtils
			sb.Clear();
			sb.AppendLine("// <auto-generated/>");
			sb.AppendLine("#nullable enable");
			sb.AppendLine();
			sb.AppendLine("using System;");
			sb.AppendLine();
			sb.AppendLine("namespace RhythmBase.Adofai.Utils;");
			sb.AppendLine();
			sb.AppendLine("partial class EventTypeUtils");
			sb.AppendLine("{");
			sb.AppendLine("	internal static System.Collections.ObjectModel.ReadOnlyDictionary<RhythmBase.Adofai.Events.EventType, RhythmBase.Adofai.Converters.EventInstanceConverterBase> converters = new(new Dictionary<RhythmBase.Adofai.Events.EventType, RhythmBase.Adofai.Converters.EventInstanceConverterBase>()");
			sb.AppendLine("	{");
			foreach (var (symbol, _) in symbols
				.Where(i => !(i.symbol.Name.StartsWith("Forward") && i.symbol.Name.EndsWith("Event")))
				.OrderBy(i => i.symbol.Name))
			{
				sb.AppendLine($"			[RhythmBase.Adofai.Events.EventType.{symbol.Name}] = new RhythmBase.Adofai.Converters.EventInstanceConverter{symbol.Name}(),");
			}
			sb.AppendLine("	});");
			sb.AppendLine("}");
			ctx.AddSource("EventTypeUtilsADLevel.g.cs", sb.ToString());
		});
	}
	#endregion

	#region Filter Converter 生成

	private static void GenerateFilterConverter(IncrementalGeneratorInitializationContext context)
	{
		HashSet<string> names = [];
		var eventClasses = context.SyntaxProvider.CreateSyntaxProvider(
			predicate: (s, _) =>
			{
				if (s is not StructDeclarationSyntax structDeclarationSyntax)
					return false;
				var ns = structDeclarationSyntax.Parent;
				var baseList = structDeclarationSyntax.BaseList;
				if (baseList is null) return false;
				var BaseTypes = baseList.Types;
				if (BaseTypes.Where(t => t.ToString().Contains("IFilter")).Any())
					return true;
				if (ns is FileScopedNamespaceDeclarationSyntax fileScopedNamespace)
				{
					return fileScopedNamespace.Name.ToString().Contains("RhythmBase.Adofai.Components.Filters");
				}
				else if (ns is NamespaceDeclarationSyntax namespaceDeclaration)
				{
					return namespaceDeclaration.Name.ToString().Contains("RhythmBase.Adofai.Components.Filters");
				}
				return false;
			},
			transform: (ctx, _) =>
			{
				//				var classDeclaration = (StructDeclarationSyntax)ctx.Node;
				//				var symbol = ctx.SemanticModel.GetDeclaredSymbol(classDeclaration);
				//				if (symbol is INamedTypeSymbol namedTypeSymbol
				//				&& (namedTypeSymbol.AllInterfaces.Any(i => i.ToDisplayString().Contains("IFilter")))//namedTypeSymbol.AllInterfaces.Any(i => i.Name.Contains("IBaseEvent"))
				//				&& (namedTypeSymbol.ContainingNamespace?.ToDisplayString().Contains("RhythmBase.Adofai.Components.Filters") ?? false)
				//				&& !namedTypeSymbol.IsAbstract
				//				)
				//				{
				//					INamedTypeSymbol? baseType = namedTypeSymbol.BaseType;
				//					if (names.Add(symbol.Name))
				//						return (symbol, baseType);
				//				}
				//#pragma warning disable CS8619 // 值中的引用类型的为 Null 性与目标类型不匹配。
				//				return (null, null);
				//#pragma warning restore CS8619 // 值中的引用类型的为 Null 性与目标类型不匹配。
				var structDeclaration = (StructDeclarationSyntax)ctx.Node;
				var symbol = ctx.SemanticModel.GetDeclaredSymbol(structDeclaration);
				return (structDeclaration, symbol);
			})
			.Where(i => i.symbol is not null)
			.Collect();

		context.RegisterSourceOutput(eventClasses, (ctx, symbols) =>
		{
			var sb = new StringBuilder();
			sb.AppendLine("// <auto-generated/>");
			sb.AppendLine("#nullable enable");
			sb.AppendLine();
			sb.AppendLine("using System;");
			sb.AppendLine("using RhythmBase.Global.Extensions;");
			sb.AppendLine("using RhythmBase.Global.Components;");
			sb.AppendLine("using RhythmBase.Global.Components.Easing;");
			sb.AppendLine("using RhythmBase.Global.Components.RichText;");
			sb.AppendLine("using RhythmBase.Adofai.Components.Filters;");
			sb.AppendLine("using System.Text.Json;");
			sb.AppendLine();
			sb.AppendLine("namespace RhythmBase.Adofai.Converters;");
			sb.AppendLine();

			foreach (var (syntax, baseType) in symbols
				.Where(i => !i.symbol.GetAttributes().Any(a => a.AttributeClass?.ToDisplayString() == JsonObjectNotSerializableAttrName))
				.OrderBy(i => i.symbol.Name))
			{
				if (syntax is null)
					continue;
				StructDeclarationSyntax e = syntax;
				var properties = e.Members
					.OfType<PropertyDeclarationSyntax>()
					.Where(p =>
						p.Modifiers.Any(m => m.IsKind(SyntaxKind.PublicKeyword)) &&
						(
							(p.AccessorList?.Accessors.Any(
								a => a.Kind() == SyntaxKind.SetAccessorDeclaration) ?? false) ||
							p.AttributeLists.Any(
								i => i.Attributes.Any(
									j => j.Name.GetLastToken().ToFullString() == JsonNotIgnoreAttrName))
						)
						)
					.ToList();

				sb.AppendLine($"internal class FilterInstanceConverter{e.ToFullString()} : FilterInstanceConverterBase<{e.ToFullString()}>");
				sb.AppendLine("{");
				// Read
				sb.AppendLine($"	protected override bool Read(ref Utf8JsonReader reader, ReadOnlySpan<byte> propertyName, ref {e.ToFullString()} value, JsonSerializerOptions options)");
				sb.AppendLine("	{");
				if (properties.Count > 0)
				{
					sb.AppendLine("		if(base.Read(ref reader, propertyName, ref value, options))");
					sb.AppendLine("			return true;");
					AppendEventReadBody(sb, properties, e);
				}
				else
				{
					sb.AppendLine("		return base.Read(ref reader, propertyName, ref value, options);");
				}
				sb.AppendLine("	}");

				// Write
				sb.AppendLine($"	protected override void Write(Utf8JsonWriter writer, ref {e.ToFullString()} value, JsonSerializerOptions options)");
				sb.AppendLine("	{");
				sb.AppendLine("		base.Write(writer, ref value, options);");
				AppendEventWriteBody(sb, properties, e);
				sb.AppendLine("	}");
				sb.AppendLine("}");
			}
			ctx.AddSource("FilterInstanceConverter.g.cs", sb.ToString());

			// EventTypeUtils
			sb.Clear();
			sb.AppendLine("// <auto-generated/>");
			sb.AppendLine("#nullable enable");
			sb.AppendLine();
			sb.AppendLine("using System;");
			sb.AppendLine();
			sb.AppendLine("namespace RhythmBase.Adofai.Utils;");
			sb.AppendLine();
			sb.AppendLine("internal partial class FilterTypeUtils");
			sb.AppendLine("{");
			sb.AppendLine("	internal static System.Collections.ObjectModel.ReadOnlyDictionary<string, RhythmBase.Adofai.Converters.FilterInstanceConverterBase> converters = new(new Dictionary<string, RhythmBase.Adofai.Converters.FilterInstanceConverterBase>()");
			sb.AppendLine("	{");

			foreach (var (symbol, _) in symbols
				.OrderBy(i => i.symbol.Name))
			{
				//var filterName = symbol
				//	.GetMembers()
				//	.OfType<IPropertySymbol>()
				//	.FirstOrDefault(p =>
				//		p.Name == "Name");

				sb.AppendLine($"			//{symbol.ToFullString()}");
				sb.AppendLine($"			[\"{symbol.ToFullString()}\"] = new RhythmBase.Adofai.Converters.FilterInstanceConverter{symbol.ToFullString()}(),");
			}
			sb.AppendLine("	});");
			sb.AppendLine("}");
			ctx.AddSource("FilterTypeUtilsADLevel.g.cs", sb.ToString());
		});
	}
	#endregion

	#region 工具方法

	private static string TypeNameOf(ITypeSymbol symbol)
	{
		if (symbol is INamedTypeSymbol namedTypeSymbol)
		{
			if (namedTypeSymbol.TypeArguments.Length > 0)
			{
				var typeArgs = string.Join(", ", namedTypeSymbol.TypeArguments.Select(t => t.ToDisplayString()));
				return $"{namedTypeSymbol.Name}<{typeArgs}>";
			}
			else
			{
				return namedTypeSymbol.Name;
			}
		}
		else if (symbol is IArrayTypeSymbol)
		{
			return symbol.ToDisplayString();
		}
		return "";
	}
	private static string TypeNameOf(TypeSyntax symbol)
	{
		return symbol.ToFullString();
	}

	private static string LastPartOf(string str) => str.Split('.').Last();

	private static string ToLowerCamelCase(string str)
	{
		if (string.IsNullOrEmpty(str) || str.Length < 2)
			return str.ToLower();
		return char.ToLower(str[0]) + str.Substring(1);
	}
	private static string GetFullNamespace(INamedTypeSymbol type)
	{
		if (type == null) return string.Empty;

		var ns = type.ContainingNamespace;
		if (ns == null || ns.IsGlobalNamespace)   // 顶级命名空间
			return string.Empty;

		return ns.ToDisplayString();   // 自带“.”连接
	}
	#endregion

#pragma warning disable IDE0060

	// 分离的 Read 代码生成
	private static void AppendEventReadBody(StringBuilder sb, List<IPropertySymbol> properties, INamedTypeSymbol e)
	{
		bool isFirst = true;
		int enumIndex = 0;
		foreach (var p in properties)
		{
			var propertyName = p.Name;
			var jsonName = p.Name;
			var type = p.Type;

			if (p.GetAttributes().Any(i => i.AttributeClass?.ToDisplayString() == JsonIgnoreAttrName))
				continue;
			if (p.SetMethod == null)
				continue;
			var nameAttr = p.GetAttributes().FirstOrDefault(i => i.AttributeClass?.ToDisplayString() == JsonPropertyAttrName);
			var timeAttr = p.GetAttributes().FirstOrDefault(i => i.AttributeClass?.ToDisplayString() == JsonTimeAttrName);
			var converterAttr = p.GetAttributes().FirstOrDefault(i => i.AttributeClass?.ToDisplayString() == JsonConverterAttrName);
			if (nameAttr is not null)
			{
				var args = nameAttr.ConstructorArguments;
				if (args != null)
					foreach (var arg in args)
						jsonName = args[0].Value?.ToString() ?? propertyName;
			}
			else
			{
				jsonName = ToLowerCamelCase(LastPartOf(propertyName));
			}

			var name2 = propertyName;
			var type2 = type;
			bool isNullable = false;
			if (converterAttr != null)
			{
				string converterTypeName = converterAttr.ConstructorArguments[0].Value?.ToString() ?? "?";
				sb.AppendLine($"		{(isFirst ? "" : "else ")}if (propertyName.SequenceEqual(\"{jsonName}\"u8))");
				sb.AppendLine($"			value.{propertyName} = new {converterTypeName}().Read(ref reader, typeof({TypeNameOf(type)}), options);");
				isFirst = false;
				continue;
			}
			else if (type is IArrayTypeSymbol || p.GetAttributes().Any(i => i.AttributeClass?.ToDisplayString() == JsonDefaultSerializerAttrName))
			{
				sb.AppendLine($"		{(isFirst ? "" : "else ")}if (propertyName.SequenceEqual(\"{jsonName}\"u8))");
				sb.AppendLine($"			value.{propertyName} = JsonSerializer.Deserialize<{TypeNameOf(type)}>(ref reader, options) ?? {(type is IArrayTypeSymbol ? "[]" : "new()")};");
				isFirst = false;
				continue;
			}
			else if (timeAttr != null)
			{
				string timeType = timeAttr.ConstructorArguments.Length > 0 ? timeAttr.ConstructorArguments[0].Value?.ToString() ?? "" : "";
				sb.AppendLine($"		{(isFirst ? "" : "else ")}if (propertyName.SequenceEqual(\"{jsonName}\"u8))");
				switch (timeType)
				{
					case "seconds":
						sb.AppendLine($"			value.{propertyName} = TimeSpan.FromSeconds(reader.GetDouble());");
						break;
					case "milliseconds":
						sb.AppendLine($"			value.{propertyName} = TimeSpan.FromMilliseconds(reader.GetDouble());");
						break;
				}
				isFirst = false;
				continue;
			}
			else
			{
				if (type.NullableAnnotation == NullableAnnotation.Annotated)
				{
					name2 = propertyName + "?";
					if (((INamedTypeSymbol)type).TypeArguments.Length > 0)
					{
						type2 = ((INamedTypeSymbol)type).TypeArguments[0];
						sb.AppendLine($"// Found GenericType: {type2.Name}, {type2.MetadataName}");
					}
					isNullable = true;
				}
				if (type2.TypeKind == TypeKind.Enum)
				{
					sb.AppendLine($"		{(isFirst ? "" : "else ")}if (" +
						$"propertyName.SequenceEqual(\"{jsonName}\"u8) && " +
						(isNullable ? $"reader.TokenType is not JsonTokenType.Null && " : "") +
						$"TryParse(reader.ValueSpan, out {type.ToDisplayString().TrimEnd('?')} enumValue{enumIndex}))");
					sb.AppendLine($"			value.{propertyName} = enumValue{enumIndex};");
					enumIndex++;
				}
				else
				{
					sb.AppendLine($"		{(isFirst ? "" : "else ")}if (propertyName.SequenceEqual(\"{jsonName}\"u8))");
					if (isNullable)
					{
						sb.AppendLine($"			if(reader.TokenType is JsonTokenType.Null)");
						sb.AppendLine($"				value.{propertyName} = null;");
						sb.AppendLine("			else");
						sb.Append('	');
					}

					switch (type2.SpecialType)
					{
						case SpecialType.System_Boolean or
							SpecialType.System_Byte or
							SpecialType.System_Int16 or
							SpecialType.System_Int32 or
							SpecialType.System_Int64 or
							SpecialType.System_UInt16 or
							SpecialType.System_UInt32 or
							SpecialType.System_UInt64 or
							SpecialType.System_Single or
							SpecialType.System_Double or
							SpecialType.System_Decimal:
							sb.AppendLine($"			value.{propertyName} = reader.Get{type2.SpecialType.ToString().Replace("System_", "")}();");
							break;
						case SpecialType.System_String:
							sb.AppendLine($"			value.{propertyName} = reader.GetString() ?? \"\";");
							break;
						default:
							sb.AppendLine($"			value.{propertyName} = JsonSerializer.Deserialize<{TypeNameOf(type)}>(ref reader, options){(
								type.Name.Contains("List") ? " ?? []" :
								 "")};");
							break;
					}
				}
				isFirst = false;
			}
		}
		sb.AppendLine("		else");
		sb.AppendLine("			return false;");
		sb.AppendLine("		return true;");
	}
	// 分离的 Write 代码生成
	private static void AppendEventWriteBody(StringBuilder sb, List<IPropertySymbol> properties, INamedTypeSymbol e)
	{
		foreach (var p in properties)
		{
			var propertyName = p.Name;
			var jsonName = p.Name;
			var type = p.Type;
			if (p.GetAttributes().Any(i => i.AttributeClass?.ToDisplayString() == JsonIgnoreAttrName))
				continue;
			if (p.GetMethod == null && !p.GetAttributes().Any(i => i.AttributeClass?.ToDisplayString() == JsonNotIgnoreAttrName))
				continue;
			var nameAttr = p.GetAttributes().FirstOrDefault(i => i.AttributeClass?.ToDisplayString() == JsonPropertyAttrName);
			var timeAttr = p.GetAttributes().FirstOrDefault(i => i.AttributeClass?.ToDisplayString() == JsonTimeAttrName);
			var converterAttr = p.GetAttributes().FirstOrDefault(i => i.AttributeClass?.ToDisplayString() == JsonConverterAttrName);
			if (nameAttr is not null)
			{
				var args = nameAttr.ConstructorArguments;
				if (args != null)
					foreach (var arg in args)
						jsonName = args[0].Value?.ToString() ?? propertyName;
			}
			else
			{
				jsonName = ToLowerCamelCase(LastPartOf(propertyName));
			}

			var conditionAttr = p.GetAttributes().FirstOrDefault(i => i.AttributeClass?.ToDisplayString() == JsonConditionAttrName);
			string condition = "";
			if (conditionAttr is not null)
			{
				var args = conditionAttr.ConstructorArguments;
				if (args != null)
					foreach (var arg in args)
						condition = args[0].Value?.ToString() ?? "";
			}

			var name2 = propertyName;
			var type2 = type;
			bool hasCondition = !string.IsNullOrEmpty(condition);
			if (hasCondition)
			{
				sb.AppendLine($"		if ({condition})".Replace("$&", "value").Replace("\n", "\n\t\t\t"));
				sb.Append('	');
			}
			if (converterAttr != null)
			{
				string converterTypeName = converterAttr.ConstructorArguments[0].Value?.ToString() ?? "?";
				if (hasCondition)
					sb.Append("		{\n	");
				sb.AppendLine($"		writer.WritePropertyName(\"{jsonName}\"u8);");
				sb.AppendLine($"		new {converterTypeName}().Write(writer, value.{propertyName}, options);");
				if (hasCondition)
					sb.AppendLine("		}");
				continue;
			}
			else if (type is IArrayTypeSymbol || p.GetAttributes().Any(i => i.AttributeClass?.ToDisplayString() == JsonDefaultSerializerAttrName))
			{
				if (hasCondition)
					sb.Append("		{\n	");
				sb.AppendLine($"		writer.WritePropertyName(\"{jsonName}\"u8);");
				if (hasCondition)
					sb.Append("	");
				sb.AppendLine($"		JsonSerializer.Serialize(writer, value.{propertyName}, options);");
				if (hasCondition)
					sb.AppendLine("		}");
				continue;
			}
			else if (timeAttr != null)
			{
				string timeType = timeAttr.ConstructorArguments.Length > 0 ? timeAttr.ConstructorArguments[0].Value?.ToString() ?? "" : "";
				if (hasCondition)
					sb.Append("		{\n	");
				switch (timeType)
				{
					case "seconds":
						sb.AppendLine($"		writer.WriteNumber(\"{jsonName}\"u8, value.{propertyName}.TotalSeconds);");
						break;
					case "milliseconds":
						sb.AppendLine($"		writer.WriteNumber(\"{jsonName}\"u8, value.{propertyName}.TotalMilliseconds);");
						break;
				}
				if (hasCondition)
					sb.AppendLine("		}");
				continue;
			}
			else if (type.NullableAnnotation == NullableAnnotation.Annotated)
			{

				name2 = propertyName + "?";
				if (((INamedTypeSymbol)type).TypeArguments.Length > 0)
				{
					type2 = ((INamedTypeSymbol)type).TypeArguments[0];
					sb.AppendLine($"// Found GenericType: {type2.Name}, {type2.MetadataName}");
				}
			}
			if (type.TypeKind == TypeKind.Enum)
			{
				sb.AppendLine($"		writer.WriteString(\"{jsonName}\"u8, value.{propertyName}.ToEnumString());");
			}
			else
			{
				switch (type.SpecialType)
				{
					case SpecialType.System_Boolean:
						sb.AppendLine($"		writer.WriteBoolean(\"{jsonName}\"u8, value.{LastPartOf(propertyName)});");
						break;
					case SpecialType.System_String:
						sb.AppendLine($"		writer.WriteString(\"{jsonName}\"u8, value.{LastPartOf(propertyName)});");
						break;
					case SpecialType.System_Byte or
						SpecialType.System_Int16 or
						SpecialType.System_Int32 or
						SpecialType.System_Int64 or
						SpecialType.System_UInt16 or
						SpecialType.System_UInt32 or
						SpecialType.System_UInt64 or
						SpecialType.System_Single or
						SpecialType.System_Double or
						SpecialType.System_Decimal:
						sb.AppendLine($"		writer.WriteNumber(\"{jsonName}\"u8, value.{LastPartOf(propertyName)});");
						break;
					default:
						if (hasCondition)
							sb.Append("		{\n	");
						sb.AppendLine($"		writer.WritePropertyName(\"{jsonName}\"u8);");
						if (hasCondition)
							sb.Append("	");
						sb.AppendLine($"		JsonSerializer.Serialize(writer, value.{propertyName}, options);");
						if (hasCondition)
							sb.AppendLine("		}");
						break;
				}
			}
		}
	}
	// 分离的 Read 代码生成
	private static void AppendEventReadBody(StringBuilder sb, List<PropertyDeclarationSyntax> properties, StructDeclarationSyntax e)
	{
		bool isFirst = true;
		int enumIndex = 0;
		foreach (var p in properties)
		{
			var propertyName = p.ToFullString();
			var jsonName = p.ToFullString();
			var type = p.Type;

			if (p.AttributeLists.Any(
				i => i.Attributes.Any(
					j => j.ToFullString() == JsonIgnoreAttrName)))
				continue;
			if ((!p.AccessorList?.Accessors.Any(
				i => i.Kind() == SyntaxKind.SetAccessorDeclaration)) ?? false)
				continue;
			var nameAttr = GetAttributeSyntax(p, JsonPropertyAttrName);
			var timeAttr = GetAttributeSyntax(p, JsonTimeAttrName);
			var converterAttr = GetAttributeSyntax(p, JsonConverterAttrName);
			if (nameAttr is not null)
			{
				var args = nameAttr.ArgumentList;
				if (args != null)
					jsonName = args.Arguments[0].ToFullString().Trim('"');
			}
			else
			{
				jsonName = ToLowerCamelCase(LastPartOf(propertyName));
			}

			var name2 = propertyName;
			var type2 = type;
			bool isNullable = false;
			if (converterAttr != null)
			{
				string converterTypeName = (converterAttr.ArgumentList?.Arguments[0].Expression as TypeOfExpressionSyntax)?.Type.ToFullString() ?? "?";
				sb.AppendLine($"		{(isFirst ? "" : "else ")}if (propertyName.SequenceEqual(\"{jsonName}\"u8))");
				sb.AppendLine($"			value.{propertyName} = new {converterTypeName}().Read(ref reader, typeof({TypeNameOf(type)}), options);");
				isFirst = false;
				continue;
			}
			else
			{
				sb.AppendLine($"		{(isFirst ? "" : "else ")}if (propertyName.SequenceEqual(\"{jsonName}\"u8))");
				if (isNullable)
				{
					sb.AppendLine($"			if(reader.TokenType is JsonTokenType.Null)");
					sb.AppendLine($"				value.{propertyName} = null;");
					sb.AppendLine("			else");
					sb.Append('	');
				}

				if (type is PredefinedTypeSyntax predefinedTypeSyntax)
				{
					string predefinedTypePostfix = predefinedTypeSyntax.ToFullString() switch
					{
						"bool" => "Boolean",
						"byte" => "Byte",
						"sbyte" => "SByte",
						"short" => "Int16",
						"ushort" => "UInt16",
						"int" => "Int32",
						"uint" => "UInt32",
						"long" => "Int64",
						"ulong" => "UInt64",
						"float" => "Single",
						"double" => "Double",
						"decimal" => "Decimal",
						"string" => "String",
						_ => ""
					};
					if (predefinedTypePostfix == "String")
						sb.AppendLine($"			value.{propertyName} = reader.Get{predefinedTypePostfix}() ?? \"\";");
					else
						sb.AppendLine($"			value.{propertyName} = reader.Get{predefinedTypePostfix}();");
					isFirst = false;
					continue;
				}
				sb.AppendLine($"			value.{propertyName} = JsonSerializer.Deserialize<{TypeNameOf(type)}>(ref reader, options){(
					type.ToFullString().Contains("List") ? " ?? []" :
					 "")};");
				isFirst = false;
				continue;

			}
		}
		sb.AppendLine("		else");
		sb.AppendLine("			return false;");
		sb.AppendLine("		return true;");
	}
	// 分离的 Write 代码生成
	private static void AppendEventWriteBody(StringBuilder sb, List<PropertyDeclarationSyntax> properties, StructDeclarationSyntax e)
	{
		foreach (var p in properties)
		{
			var propertyName = p.ToFullString();
			var jsonName = p.ToFullString();
			var type = p.Type;
			if (GetAttributeSyntax(p, JsonIgnoreAttrName) is not null)
				continue;
			if (((!p.AccessorList?.Accessors.Any(
				i => i.Kind() == SyntaxKind.GetAccessorDeclaration)) ?? false) &&
				GetAttributeSyntax(p, JsonIgnoreAttrName) is not null)
				continue;
			var nameAttr = GetAttributeSyntax(p, JsonPropertyAttrName);
			var timeAttr = GetAttributeSyntax(p, JsonTimeAttrName);
			var converterAttr = GetAttributeSyntax(p, JsonConverterAttrName);
			if (nameAttr is not null)
			{
				var args = nameAttr.ArgumentList;
				if (args != null && args.Arguments.Count > 0)
					jsonName = args.Arguments[0].ToFullString().Trim('"');
			}
			else
			{
				jsonName = ToLowerCamelCase(LastPartOf(propertyName));
			}

			var name2 = propertyName;
			var type2 = type;
			if (converterAttr != null)
			{
				string converterTypeName = (converterAttr.ArgumentList?.Arguments[0].Expression as TypeOfExpressionSyntax)?.Type.ToFullString() ?? "?";
				sb.AppendLine($"		writer.WritePropertyName(\"{jsonName}\"u8);");
				sb.AppendLine($"		new {converterTypeName}().Write(writer, value.{propertyName}, options);");
				continue;
			}
			else if (type is PredefinedTypeSyntax predefinedTypeSyntax)
			{
				string predefinedTypePostfix = predefinedTypeSyntax.ToFullString() switch
				{
					"bool" => "Boolean",
					"byte" => "Byte",
					"sbyte" => "SByte",
					"short" => "Int16",
					"ushort" => "UInt16",
					"int" => "Int32",
					"uint" => "UInt32",
					"long" => "Int64",
					"ulong" => "UInt64",
					"float" => "Single",
					"double" => "Double",
					"decimal" => "Decimal",
					"string" => "String",
					_ => ""
				};
				if (predefinedTypePostfix == "String")
					sb.AppendLine($"		writer.WriteString(\"{jsonName}\"u8, value.{LastPartOf(propertyName)});");
				else if (predefinedTypePostfix == "Boolean")
					sb.AppendLine($"		writer.WriteBoolean(\"{jsonName}\"u8, value.{LastPartOf(propertyName)});");
				else
					sb.AppendLine($"		writer.WriteNumber(\"{jsonName}\"u8, value.{LastPartOf(propertyName)});");
				continue;
			}
			else
			{
				sb.AppendLine($"		writer.WritePropertyName(\"{jsonName}\"u8);");
				sb.AppendLine($"		JsonSerializer.Serialize(writer, value.{propertyName}, options);");
				break;
			}
		}
	}
	private static AttributeSyntax? GetAttributeSyntax(PropertyDeclarationSyntax property, string attributeFullName)
	{
		foreach (var attrList in property.AttributeLists)
		{
			foreach (var attr in attrList.Attributes)
			{
				var name = attr.Name.ToString();
				if (name == attributeFullName || name.EndsWith("." + attributeFullName))
				{
					return attr;
				}
			}
		}
		return null;
	}
}

