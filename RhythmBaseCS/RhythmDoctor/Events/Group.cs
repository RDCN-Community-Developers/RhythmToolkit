using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using RhythmBase.Global.Exceptions;
using RhythmBase.RhythmDoctor.Utils;
using System.Collections;
using System.Diagnostics.CodeAnalysis;
using System.Text.RegularExpressions;

namespace RhythmBase.RhythmDoctor.Events
{
	/// <summary>
	/// Represents a group of events in Rhythm Doctor.
	/// </summary>
	public abstract partial class Group : BaseEvent, IEnumerable<BaseEvent>
	{
		/// <summary>
		/// Gets the type of the event, which is always <see cref="EventType.Group"/> for this class.
		/// </summary>
		public override EventType Type => EventType.Group;
		/// <summary>
		/// Gets the tab associated with this event, which is <see cref="Tabs.Unknown"/> by default.
		/// </summary>
		public override Tabs Tab => Tabs.Unknown;
		/// <summary>  
		/// Initializes a new instance of the <see cref="Group"/> class.  
		/// </summary>  
		/// <remarks>  
		/// The constructor assigns a unique hexadecimal string to the <see cref="GroupTag"/> property,  
		/// which is derived from the hash code of the instance.  
		/// </remarks>  
		public Group()
		{
			GroupTag = GetHashCode().ToString("X8");
		}
		/// <summary>
		/// Retrieves the collection of events contained within this group.
		/// </summary>
		/// <returns>An enumerable collection of <see cref="BaseEvent"/> objects.</returns>
		public abstract IEnumerable<BaseEvent> GenerateEvents();
		/// <summary>
		/// Retrieves the events in the group with additional tagging and comments.
		/// </summary>
		/// <param name="tag">The tag to apply to the events.</param>
		/// <param name="comment">The comment to associate with the events.</param>
		/// <returns>An enumerable collection of <see cref="BaseEvent"/> objects with tagging and comments applied.</returns>
		/// <exception cref="InvalidRDBeatException">Thrown if any event in the group has an empty beat.</exception>
		protected abstract JObject Data { get; set; }
		private IEnumerable<BaseEvent> GetTaggedEvents(string tag, string comment)
		{
			BaseEvent[] events = [.. GenerateEvents().OrderBy(i => {
				i._beat._calculator = _beat._calculator; return i.Beat;
			})];
			if (events.Length == 0)
				yield break;
			var startBeat = events.Min(i => i.Beat);
			yield return new Comment()
			{
				Beat = Beat,
				Text = tag + "\n/* " + comment + " */\n" + Data.ToString(Formatting.None),
			};
			yield return new TagAction()
			{
				Beat = startBeat,
				ActionTag = tag,
			};
			HashSet<string> tags = [];
			foreach (BaseEvent ev in events)
			{
				if (string.IsNullOrEmpty(ev.Tag))
					ev.Tag = tag;
				else
				{
					string preTag = ev.Tag;
					string newTag = tag + "_" + ev.Tag;
					if (tags.Add(newTag))
					{
						TagAction action = new()
						{
							Beat = ev.Beat,
							Tag = preTag,
							ActionTag = newTag,
						};
						yield return action;
					}
					ev.Tag = newTag;
				}
				yield return ev;
			}
		}
		/// <summary>
		/// Returns an enumerator that iterates through the events in the group.
		/// </summary>
		/// <returns>An enumerator for the events in the group.</returns>
		public IEnumerator<BaseEvent> GetEnumerator() => GetTaggedEvents(
			$"RDTKGROUP_{GetType().Name}_{GroupTag}",
			"Group events generated by RDTK."
			).GetEnumerator();
		/// <summary>
		/// Returns an enumerator that iterates through the events in the group.
		/// </summary>
		/// <returns>An enumerator for the events in the group.</returns>
		IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
		internal string GroupTag { get; private set; }
		internal static bool TryParse(Comment comment, [NotNullWhen(true)] out Group? result)
		{
			string[] lines = comment.Text.Split(['\r', '\n'], 2, StringSplitOptions.RemoveEmptyEntries);
			if (MatchTag(lines[0], out string typeName, out string id, out _))
			{
				if (!EventTypeUtils.GroupTypes.TryGetValue(typeName, out Type? groupType))
					throw new IllegalEventTypeException(typeName, "This value does not exist in the EventType enumeration.");
				Group group = (Group)Activator.CreateInstance(groupType)!;
				group.GroupTag = id;
				group.Beat = comment.Beat;
				group.Tag = id;
				group.Condition = comment.Condition;
				group.Active = comment.Active;
				group.Data = JObject.Parse(ReplaceCommentMatch().Replace(lines[1], ""));
				result = group;
				return true;
			}
			result = null;
			return false;
		}
		internal static bool MatchTag(string tag, out string typeName, out string id, out string tagstag)
		{
			tagstag = "";
			Match match = TagMatch().Match(tag);
			if (match.Success)
			{
				typeName = match.Groups[1].Value;
				id = match.Groups[2].Value;
				tagstag = match.Groups[4].Value;
				return true;
			}
			typeName = "";
			id = "";
			return false;
		}
		[GeneratedRegex(@"^RDTKGROUP_([a-zA-Z_][a-zA-Z0-9_]*)_([0-9A-F]{8})(_(.+))?$")]
		private static partial Regex TagMatch();
		[GeneratedRegex(@"/\*.*\*/")]
		private static partial Regex ReplaceCommentMatch();
	}
}
